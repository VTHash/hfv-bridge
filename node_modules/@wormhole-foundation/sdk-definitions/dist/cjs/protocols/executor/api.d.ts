import type { Chain } from "@wormhole-foundation/sdk-base";
import type { SignedQuote, TxHash } from "../../index.js";
export declare enum RelayStatus {
    Pending = "pending",
    Failed = "failed",
    Unsupported = "unsupported",
    Submitted = "submitted",
    Underpaid = "underpaid",
    Aborted = "aborted"
}
export type RequestForExecution = {
    quoterAddress: `0x${string}`;
    amtPaid: string;
    dstChain: number;
    dstAddr: `0x${string}`;
    refundAddr: `0x${string}`;
    signedQuoteBytes: `0x${string}`;
    requestBytes: `0x${string}`;
    relayInstructionsBytes: `0x${string}`;
    timestamp: Date;
};
export type TxInfo = {
    txHash: string;
    chainId: number;
    blockNumber: string;
    blockTime: Date | null;
    cost: string;
};
export type RelayData = {
    id: `0x${string}`;
    txHash: string;
    chainId: number;
    status: string;
    estimatedCost: string;
    requestForExecution: RequestForExecution;
    instruction?: Request;
    txs?: TxInfo[];
    indexed_at: Date;
};
export declare enum RequestPrefix {
    ERM1 = "ERM1",// MM
    ERV1 = "ERV1",// VAA_V1
    ERN1 = "ERN1",// NTT_V1
    ERC1 = "ERC1",// CCTP_V1
    ERC2 = "ERC2"
}
export type Capabilities = {
    requestPrefixes: Array<keyof typeof RequestPrefix>;
    gasDropOffLimit: string;
    maxGasLimit: string;
    maxMsgValue: string;
};
export interface CapabilitiesResponse {
    [chainId: string]: Capabilities;
}
export interface QuoteResponse {
    signedQuote: `0x${string}`;
    estimatedCost?: string;
}
export interface StatusResponse extends RelayData {
    signedQuote: SignedQuote;
    estimatedCost: string;
}
export declare function fetchCapabilities(apiBaseUrl: string): Promise<CapabilitiesResponse>;
export declare function fetchQuote(apiBaseUrl: string, srcChain: Chain, dstChain: Chain, relayInstructions: string): Promise<QuoteResponse>;
export declare function fetchStatus(apiBaseUrl: string, txHash: TxHash, chain: Chain): Promise<StatusResponse[]>;
//# sourceMappingURL=api.d.ts.map