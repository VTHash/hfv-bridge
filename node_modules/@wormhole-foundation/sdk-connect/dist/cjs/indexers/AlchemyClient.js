"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("./utils.js");
const ALCHEMY_CHAINS = {
    Mainnet: {
        Ethereum: "eth-mainnet",
        Base: "base-mainnet",
        Arbitrum: "arb-mainnet",
        Optimism: "opt-mainnet",
        Polygon: "polygon-mainnet",
        Worldchain: "worldchain-mainnet",
        Ink: "ink-mainnet",
        Unichain: "unichain-mainnet",
        Berachain: "berachain-mainnet",
        Celo: "celo-mainnet",
        Linea: "linea-mainnet",
    },
    Testnet: {
        Ethereum: "eth-sepolia",
        Base: "base-sepolia",
        Arbitrum: "arb-sepolia",
        Optimism: "opt-sepolia",
        Polygon: "polygon-amoy",
        Worldchain: "worldchain-sepolia",
        Ink: "ink-sepolia",
        Unichain: "unichain-sepolia",
        Berachain: "berachain-bartio",
        Monad: "monad-testnet",
    },
    Devnet: {},
};
const RPC_ID_TOKEN_BALANCES = 1;
const RPC_ID_NATIVE_BALANCE = 2;
class AlchemyClient {
    key;
    constructor(key) {
        this.key = key;
    }
    supportsChain(network, chain) {
        const endpoint = ALCHEMY_CHAINS[network][chain];
        return endpoint !== undefined;
    }
    async batchFetchFromAlchemy(endpoint, requests, signal) {
        const baseUrl = `https://${endpoint}.g.alchemy.com/v2/${this.key}`;
        const response = await fetch(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requests.map((req) => ({
                jsonrpc: "2.0",
                id: req.id,
                method: req.method,
                params: req.params,
            }))),
            signal,
        });
        if (!response.ok) {
            throw new Error(`Alchemy API request failed with status ${response.status}`);
        }
        const data = await response.json();
        return data;
    }
    parseEthTokenResponse(tokenBalances, bals) {
        for (let item of tokenBalances) {
            const bal = (0, utils_js_1.parseBalance)(item.tokenBalance || item.balance);
            if (bal !== null) {
                bals[item.contractAddress] = bal;
            }
        }
    }
    parseEthNativeResponse(nativeBalance, bals) {
        const nativeBal = (0, utils_js_1.parseBalance)(nativeBalance);
        if (nativeBal !== null) {
            bals.native = nativeBal;
        }
    }
    async getBalances(network, chain, walletAddr, signal) {
        const endpoint = ALCHEMY_CHAINS[network][chain];
        if (!endpoint) {
            throw new Error("Chain not supported by Alchemy indexer");
        }
        const responses = await this.batchFetchFromAlchemy(endpoint, [
            {
                method: "alchemy_getTokenBalances",
                params: [walletAddr, "erc20"],
                id: RPC_ID_TOKEN_BALANCES,
            },
            { method: "eth_getBalance", params: [walletAddr, "latest"], id: RPC_ID_NATIVE_BALANCE },
        ], signal);
        const bals = {};
        for (const response of responses) {
            if (!response) {
                continue;
            }
            if (response.id === RPC_ID_TOKEN_BALANCES && response.result?.tokenBalances) {
                this.parseEthTokenResponse(response.result.tokenBalances, bals);
            }
            else if (response.id === RPC_ID_NATIVE_BALANCE && response.result) {
                this.parseEthNativeResponse(response.result, bals);
            }
        }
        return bals;
    }
}
exports.default = AlchemyClient;
//# sourceMappingURL=AlchemyClient.js.map