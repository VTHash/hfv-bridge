import type { Chain } from "./chains.js";
export declare const platforms: ["Evm", "Solana", "Cosmwasm", "Btc", "Algorand", "Sui", "Aptos", "Near", "Stacks"];
export type Platform = (typeof platforms)[number];
export declare const platformToChains: (<const K1 extends "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Stacks" | "Evm" | "Cosmwasm">(args_0: K1) => {
    readonly Evm: readonly ["Arbitrum", "Avalanche", "Base", "Bsc", "Celo", "Ethereum", "Fantom", "Klaytn", "Moonbeam", "Optimism", "Polygon", "Sepolia", "ArbitrumSepolia", "BaseSepolia", "OptimismSepolia", "Holesky", "PolygonSepolia", "Mantle", "Scroll", "Xlayer", "Linea", "Berachain", "Seievm", "Unichain", "Worldchain", "Ink", "HyperEVM", "Monad", "Mezo", "Sonic", "Converge", "Plume", "XRPLEVM", "Plasma", "CreditCoin", "HyperCore", "Moca"];
    readonly Solana: readonly ["Solana", "Pythnet", "Fogo"];
    readonly Cosmwasm: readonly ["Cosmoshub", "Evmos", "Injective", "Kujira", "Osmosis", "Sei", "Wormchain", "Dymension", "Neutron", "Stargaze", "Celestia", "Seda", "Provenance", "Noble"];
    readonly Btc: readonly ["Btc"];
    readonly Algorand: readonly ["Algorand"];
    readonly Sui: readonly ["Sui"];
    readonly Aptos: readonly ["Aptos"];
    readonly Near: readonly ["Near"];
    readonly Stacks: readonly ["Stacks"];
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => readonly ["Arbitrum", "Avalanche", "Base", "Bsc", "Celo", "Ethereum", "Fantom", "Klaytn", "Moonbeam", "Optimism", "Polygon", "Sepolia", "ArbitrumSepolia", "BaseSepolia", "OptimismSepolia", "Holesky", "PolygonSepolia", "Mantle", "Scroll", "Xlayer", "Linea", "Berachain", "Seievm", "Unichain", "Worldchain", "Ink", "HyperEVM", "Monad", "Mezo", "Sonic", "Converge", "Plume", "XRPLEVM", "Plasma", "CreditCoin", "HyperCore", "Moca"] | readonly ["Solana", "Pythnet", "Fogo"] | readonly ["Cosmoshub", "Evmos", "Injective", "Kujira", "Osmosis", "Sei", "Wormchain", "Dymension", "Neutron", "Stargaze", "Celestia", "Seda", "Provenance", "Noble"] | readonly ["Btc"] | readonly ["Algorand"] | readonly ["Sui"] | readonly ["Aptos"] | readonly ["Near"] | readonly ["Stacks"] | undefined;
};
export declare const chainToPlatform: (<const K1 extends "Solana" | "Ethereum" | "Bsc" | "Polygon" | "Avalanche" | "Algorand" | "Fantom" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Pythnet" | "Btc" | "Base" | "Sei" | "Scroll" | "Mantle" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Unichain" | "Worldchain" | "Ink" | "HyperEVM" | "Monad" | "Mezo" | "Fogo" | "Sonic" | "Converge" | "Plume" | "XRPLEVM" | "Plasma" | "CreditCoin" | "Stacks" | "Moca" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Noble" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia" | "HyperCore">(args_0: K1) => {
    Arbitrum: "Evm";
    Avalanche: "Evm";
    Base: "Evm";
    Bsc: "Evm";
    Celo: "Evm";
    Ethereum: "Evm";
    Fantom: "Evm";
    Klaytn: "Evm";
    Moonbeam: "Evm";
    Optimism: "Evm";
    Polygon: "Evm";
    Sepolia: "Evm";
    ArbitrumSepolia: "Evm";
    BaseSepolia: "Evm";
    OptimismSepolia: "Evm";
    Holesky: "Evm";
    PolygonSepolia: "Evm";
    Mantle: "Evm";
    Scroll: "Evm";
    Xlayer: "Evm";
    Linea: "Evm";
    Berachain: "Evm";
    Seievm: "Evm";
    Unichain: "Evm";
    Worldchain: "Evm";
    Ink: "Evm";
    HyperEVM: "Evm";
    Monad: "Evm";
    Mezo: "Evm";
    Sonic: "Evm";
    Converge: "Evm";
    Plume: "Evm";
    XRPLEVM: "Evm";
    Plasma: "Evm";
    CreditCoin: "Evm";
    HyperCore: "Evm";
    Moca: "Evm";
    Solana: "Solana";
    Pythnet: "Solana";
    Fogo: "Solana";
    Cosmoshub: "Cosmwasm";
    Evmos: "Cosmwasm";
    Injective: "Cosmwasm";
    Kujira: "Cosmwasm";
    Osmosis: "Cosmwasm";
    Sei: "Cosmwasm";
    Wormchain: "Cosmwasm";
    Dymension: "Cosmwasm";
    Neutron: "Cosmwasm";
    Stargaze: "Cosmwasm";
    Celestia: "Cosmwasm";
    Seda: "Cosmwasm";
    Provenance: "Cosmwasm";
    Noble: "Cosmwasm";
    Btc: "Btc";
    Algorand: "Algorand";
    Sui: "Sui";
    Aptos: "Aptos";
    Near: "Near";
    Stacks: "Stacks";
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Stacks" | "Evm" | "Cosmwasm" | undefined;
};
export declare const isPlatform: (platform: string) => platform is "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Stacks" | "Evm" | "Cosmwasm";
export type PlatformToChains<P extends Platform> = ReturnType<typeof platformToChains<P>>[number];
export type ChainToPlatform<C extends Chain> = ReturnType<typeof chainToPlatform<C>>;
declare const platformAddressFormatEntries: readonly [readonly ["Evm", "hex"], readonly ["Solana", "base58"], readonly ["Cosmwasm", "bech32"], readonly ["Btc", "bech32"], readonly ["Algorand", "algorandAppId"], readonly ["Sui", "hex"], readonly ["Aptos", "hex"], readonly ["Near", "sha256"], readonly ["Stacks", "keccak256"]];
export declare const platformToAddressFormat: (<const K1 extends "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Stacks" | "Evm" | "Cosmwasm">(args_0: K1) => {
    readonly Evm: "hex";
    readonly Solana: "base58";
    readonly Cosmwasm: "bech32";
    readonly Btc: "bech32";
    readonly Algorand: "algorandAppId";
    readonly Sui: "hex";
    readonly Aptos: "hex";
    readonly Near: "sha256";
    readonly Stacks: "keccak256";
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => "hex" | "base58" | "bech32" | "algorandAppId" | "sha256" | "keccak256" | undefined;
};
export type PlatformAddressFormat = (typeof platformAddressFormatEntries)[number][1];
export {};
//# sourceMappingURL=platforms.d.ts.map