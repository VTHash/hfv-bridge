import { amount as sdkAmount, contracts } from "@wormhole-foundation/sdk-base";
import { canonicalAddress, toNative, } from "@wormhole-foundation/sdk-definitions";
import { TokenTransfer } from "../../protocols/tokenBridge/tokenTransfer.js";
import { isAttested, isFailed, TransferState } from "../../types.js";
import { Wormhole } from "../../wormhole.js";
import { AutomaticRoute } from "../route.js";
import { signSendWait } from "../../common.js";
export function executorTokenBridgeRoute(config = {}) {
    class ExecutorTokenBridgeRouteImpl extends ExecutorTokenBridgeRoute {
        static config = config;
    }
    return ExecutorTokenBridgeRouteImpl;
}
export class ExecutorTokenBridgeRoute extends AutomaticRoute {
    static IS_EXECUTOR_ROUTE = true;
    static NATIVE_GAS_DROPOFF_SUPPORTED = true;
    // @ts-ignore
    // Since we set the config on the static class, access it with this param
    // the ExecutorTokenBridgeRoute.config will always be empty
    staticConfig = this.constructor.config;
    static config = {};
    static meta = {
        name: "TokenBridgeExecutorRoute",
    };
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    static supportedChains(network) {
        if (network === "Devnet")
            return [];
        return contracts.executorTokenBridgeChains(network);
    }
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        try {
            return [await TokenTransfer.lookupDestinationToken(fromChain, toChain, sourceToken)];
        }
        catch (e) {
            return [];
        }
    }
    getDefaultOptions() {
        return { nativeGas: 0.0 };
    }
    async validate(request, params) {
        // Check that source and destination chains are different
        if (request.fromChain.chain === request.toChain.chain) {
            return {
                valid: false,
                params,
                error: new Error("Source and destination chains cannot be the same"),
            };
        }
        const amt = sdkAmount.parse(params.amount, request.source.decimals);
        const options = params.options ?? this.getDefaultOptions();
        if (options.nativeGas && (options.nativeGas > 1.0 || options.nativeGas < 0.0))
            throw new Error("Native gas must be between 0.0 and 1.0 (0% and 100%)");
        const validatedParams = {
            amount: params.amount,
            normalizedParams: { amount: amt },
            options,
        };
        return { valid: true, params: validatedParams };
    }
    async quote(request, params) {
        const supportedChains = ExecutorTokenBridgeRoute.supportedChains(request.fromChain.network);
        // Check if the fromChain and toChain are supported by the Executor Token Bridge
        if (!supportedChains.includes(request.fromChain.chain) ||
            !supportedChains.includes(request.toChain.chain)) {
            return {
                success: false,
                error: new Error(`Executor Token Bridge does not support transfers from ${request.fromChain.chain} to ${request.toChain.chain}`),
            };
        }
        try {
            let referrerFeeDbps = undefined;
            const dstTb = await request.toChain.getExecutorTokenBridge();
            let { gasLimit, msgValue } = await dstTb.estimateMsgValueAndGasLimit(request.destination.id, request.recipient);
            if (this.staticConfig.referrerFee?.referrerFeeDbps !== undefined) {
                referrerFeeDbps = this.staticConfig.referrerFee.referrerFeeDbps;
            }
            // Check for per-token fee overrides
            if (this.staticConfig.referrerFee?.tokenFeeOverrides) {
                const srcTokenAddress = canonicalAddress(request.source.id);
                const srcFeeOverride = this.staticConfig.referrerFee.tokenFeeOverrides[this.wh.network]?.[request.fromChain.chain]?.[srcTokenAddress];
                if (srcFeeOverride !== undefined) {
                    referrerFeeDbps = srcFeeOverride;
                }
            }
            // Check for per-token gas limit overrides
            if (this.staticConfig.tokenOverrides) {
                const dstTokenAddress = canonicalAddress(request.destination.id);
                const dstOverride = this.staticConfig.tokenOverrides[this.wh.network]?.[request.destination.id.chain]?.[dstTokenAddress];
                if (dstOverride?.gasLimit !== undefined) {
                    gasLimit = dstOverride.gasLimit;
                }
            }
            let referrerAddress = undefined;
            if (referrerFeeDbps !== undefined && referrerFeeDbps > 0n) {
                const referrer = this.staticConfig.referrerFee?.referrerAddresses?.[this.wh.network]?.[request.fromChain.chain];
                if (!referrer) {
                    throw new Error(`No referrer address configured for network ${this.wh.network} and chain ${request.fromChain.chain}`);
                }
                referrerAddress = Wormhole.chainAddress(request.fromChain.chain, referrer);
            }
            const referrerFee = referrerFeeDbps !== undefined && referrerAddress !== undefined
                ? { feeDbps: referrerFeeDbps, referrer: referrerAddress }
                : undefined;
            // Convert nativeGas percentage to actual amount if provided
            let nativeGas;
            if (params.options.nativeGas !== undefined) {
                const gasDropOffLimit = await TokenTransfer.getExecutorGasDropOffLimit(this.wh, request.toChain);
                nativeGas =
                    gasDropOffLimit > 0n
                        ? (BigInt(Math.round(params.options.nativeGas * 100)) * gasDropOffLimit) / 100n
                        : 0n;
            }
            const q = await TokenTransfer.quoteTransfer(this.wh, request.fromChain, request.toChain, {
                token: request.source.id,
                amount: sdkAmount.units(params.normalizedParams.amount),
                protocol: "ExecutorTokenBridge",
                nativeGas,
                msgValue,
                gasLimit,
                referrerFee,
            });
            return request.displayQuote(q, params, q.details);
        }
        catch (e) {
            return {
                success: false,
                error: e,
            };
        }
    }
    async initiate(request, signer, quote, to) {
        const { fromChain, toChain } = request;
        const { params } = quote;
        const transfer = await TokenTransfer.destinationOverrides(fromChain, toChain, this.toTransferDetails(request, params, Wormhole.chainAddress(signer.chain(), signer.address()), to, quote));
        const txids = await TokenTransfer.transfer(fromChain, transfer, signer);
        // Status the transfer immediately before returning
        let statusAttempts = 0;
        const statusTransferImmediately = async () => {
            while (statusAttempts < 20) {
                try {
                    const [txStatus] = await this.wh.getExecutorTxStatus(txids.at(-1).txid, fromChain.chain);
                    if (txStatus) {
                        break;
                    }
                }
                catch (_) {
                    // is ok we just try again!
                }
                statusAttempts++;
                await new Promise((resolve) => setTimeout(resolve, 2000));
            }
        };
        // Spawn a loop in the background that will status this transfer until
        // the API gives a successful response. We don't await the result
        // here because we don't need it for the return value.
        statusTransferImmediately();
        return {
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: TransferState.SourceInitiated,
            originTxs: txids,
        };
    }
    async complete(signer, receipt) {
        if (!isAttested(receipt) && !isFailed(receipt)) {
            throw new Error("The source must be finalized in order to complete the transfer");
        }
        if (!receipt.attestation) {
            throw new Error("The receipt must have an attestation to complete the transfer");
        }
        const toChain = this.wh.getChain(receipt.to);
        const tb = await toChain.getExecutorTokenBridge();
        const senderAddress = toNative(signer.chain(), signer.address());
        const xfer = tb.redeem(senderAddress, receipt.attestation.attestation);
        const dstTxIds = await signSendWait(toChain, xfer, signer);
        return {
            ...receipt,
            state: TransferState.DestinationInitiated,
            attestation: receipt.attestation,
            destinationTxs: dstTxIds,
        };
    }
    async resume(txid) {
        const xfer = await TokenTransfer.from(this.wh, txid, 10 * 1000);
        if (xfer.transfer.protocol !== "ExecutorTokenBridge") {
            throw new Error("Can only resume ExecutorTokenBridge transfers");
        }
        return TokenTransfer.getReceipt(xfer);
    }
    async *track(receipt, timeout) {
        for await (const r of TokenTransfer.track(this.wh, receipt, timeout)) {
            yield r;
        }
    }
    toTransferDetails(request, params, from, to, quote) {
        if (!quote.details)
            throw new Error("Missing quote details");
        return {
            from,
            to,
            token: request.source.id,
            amount: sdkAmount.units(params.normalizedParams.amount),
            protocol: "ExecutorTokenBridge",
            executorQuote: quote.details.executorQuote,
            referrerFee: quote.details.referrerFee,
        };
    }
}
//# sourceMappingURL=executor.js.map