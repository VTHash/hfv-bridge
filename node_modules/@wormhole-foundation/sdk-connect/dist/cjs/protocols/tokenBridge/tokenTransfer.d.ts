import type { Chain, Network } from "@wormhole-foundation/sdk-base";
import { amount } from "@wormhole-foundation/sdk-base";
import type { AttestationId, AutomaticTokenBridge, ChainContext, Signer, TokenId, TokenTransferDetails, TransactionId, TxHash, WormholeMessageId, ExecutorTokenBridge, ChainAddress } from "@wormhole-foundation/sdk-definitions";
import { TokenBridge } from "@wormhole-foundation/sdk-definitions";
import type { AttestationReceipt as _AttestationReceipt, TransferQuote, TransferReceipt as _TransferReceipt } from "../../types.js";
import { TransferState } from "../../types.js";
import { Wormhole } from "../../wormhole.js";
import type { WormholeTransfer } from "../wormholeTransfer.js";
export declare class TokenTransfer<N extends Network = Network> implements WormholeTransfer<TokenTransfer.Protocol> {
    private readonly wh;
    fromChain: ChainContext<N, Chain>;
    toChain: ChainContext<N, Chain>;
    private _state;
    transfer: TokenTransferDetails;
    txids: TransactionId[];
    attestations?: TokenTransfer.AttestationReceipt[];
    private constructor();
    getTransferState(): TransferState;
    static from<N extends Network>(wh: Wormhole<N>, from: TokenTransferDetails, timeout?: number, fromChain?: ChainContext<N, Chain>, toChain?: ChainContext<N, Chain>): Promise<TokenTransfer<N>>;
    static from<N extends Network>(wh: Wormhole<N>, from: WormholeMessageId, timeout?: number, fromChain?: ChainContext<N, Chain>, toChain?: ChainContext<N, Chain>): Promise<TokenTransfer<N>>;
    static from<N extends Network>(wh: Wormhole<N>, from: TransactionId, timeout?: number, fromChain?: ChainContext<N, Chain>, toChain?: ChainContext<N, Chain>): Promise<TokenTransfer<N>>;
    private static fromIdentifier;
    private static fromTransaction;
    initiateTransfer(signer: Signer): Promise<TxHash[]>;
    fetchAttestation(timeout?: number): Promise<AttestationId[]>;
    completeTransfer(signer: Signer): Promise<TxHash[]>;
}
export declare namespace TokenTransfer {
    /**  8 is maximum precision supported by the token bridge VAA */
    export const MAX_DECIMALS = 8;
    export type Protocol = "TokenBridge" | "AutomaticTokenBridge" | "ExecutorTokenBridge";
    export type VAA = TokenBridge.TransferVAA | AutomaticTokenBridge.VAA | ExecutorTokenBridge.VAA;
    export type AttestationReceipt = _AttestationReceipt<TokenTransfer.Protocol>;
    export type TransferReceipt<SC extends Chain = Chain, DC extends Chain = Chain> = _TransferReceipt<TokenTransfer.AttestationReceipt, SC, DC>;
    export function transfer<N extends Network>(fromChain: ChainContext<N, Chain>, transfer: TokenTransferDetails, signer: Signer<N, Chain>): Promise<TransactionId[]>;
    export function redeem<N extends Network>(toChain: ChainContext<N, Chain>, vaa: TokenTransfer.VAA, signer: Signer<N, Chain>): Promise<TransactionId[]>;
    export function track<N extends Network, SC extends Chain, DC extends Chain>(wh: Wormhole<N>, receipt: TokenTransfer.TransferReceipt<SC, DC>, timeout?: number, fromChain?: ChainContext<N, SC>, toChain?: ChainContext<N, DC>): AsyncGenerator<TokenTransfer.TransferReceipt<SC, DC>>;
    export function getReceipt<N extends Network>(xfer: TokenTransfer<N>): TransferReceipt;
    export function lookupDestinationToken<N extends Network, SC extends Chain, DC extends Chain>(srcChain: ChainContext<N, SC>, dstChain: ChainContext<N, DC>, token: TokenId<SC>): Promise<TokenId<DC>>;
    export function isTransferComplete<N extends Network, C extends Chain>(toChain: ChainContext<N, C>, vaa: TokenTransfer.VAA): Promise<boolean>;
    export function getTransferMessage<N extends Network, C extends Chain>(chain: ChainContext<N, C>, txid: TxHash, timeout?: number): Promise<WormholeMessageId>;
    export function getTransferVaa<N extends Network>(wh: Wormhole<N>, key: WormholeMessageId | TxHash, timeout?: number): Promise<TokenTransfer.VAA | null>;
    export function isTransferEnqueued<N extends Network>(wh: Wormhole<N>, key: WormholeMessageId): Promise<boolean>;
    export function validateTransferDetails<N extends Network>(wh: Wormhole<N>, transfer: TokenTransferDetails, fromChain?: ChainContext<N, Chain>, toChain?: ChainContext<N, Chain>): void;
    type BaseQuoteDetails = Omit<TokenTransferDetails, "from" | "to">;
    export type QuoteTransferDetails = (BaseQuoteDetails & {
        protocol: TokenBridge.ProtocolName;
        payload?: Uint8Array;
    }) | (BaseQuoteDetails & {
        protocol: AutomaticTokenBridge.ProtocolName;
        nativeGas?: bigint;
    }) | (BaseQuoteDetails & {
        protocol: ExecutorTokenBridge.ProtocolName;
        msgValue: bigint;
        gasLimit: bigint;
        nativeGas?: bigint;
        referrerFee?: {
            feeDbps: bigint;
            referrer: ChainAddress;
        };
    });
    export function quoteTransfer<N extends Network>(wh: Wormhole<N>, srcChain: ChainContext<N, Chain>, dstChain: ChainContext<N, Chain>, transfer: QuoteTransferDetails): Promise<TransferQuote>;
    export function getExecutorGasDropOffLimit<N extends Network>(wh: Wormhole<N>, dstChain: ChainContext<N, Chain>): Promise<bigint>;
    export function getExecutorQuote<N extends Network>(wh: Wormhole<N>, srcChain: ChainContext<N, Chain>, dstChain: ChainContext<N, Chain>, gasLimit: bigint, msgValue: bigint, nativeGas?: bigint): Promise<ExecutorTokenBridge.ExecutorQuote>;
    export function destinationOverrides<N extends Network>(srcChain: ChainContext<N, Chain>, dstChain: ChainContext<N, Chain>, transfer: TokenTransferDetails): Promise<TokenTransferDetails>;
    export function calculateReferrerFee(amt: amount.Amount, dBps: bigint): {
        fee: amount.Amount;
        remaining: amount.Amount;
    };
    export {};
}
//# sourceMappingURL=tokenTransfer.d.ts.map