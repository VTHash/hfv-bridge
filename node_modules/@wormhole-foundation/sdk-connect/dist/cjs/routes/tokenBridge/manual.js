"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBridgeRoute = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const tokenTransfer_js_1 = require("../../protocols/tokenBridge/tokenTransfer.js");
const types_js_1 = require("../../types.js");
const wormhole_js_1 = require("../../wormhole.js");
const route_js_1 = require("../route.js");
const sdk_base_2 = require("@wormhole-foundation/sdk-base");
class TokenBridgeRoute extends route_js_1.ManualRoute {
    static meta = {
        name: "ManualTokenBridge",
    };
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    // get the list of chains this route supports
    static supportedChains(network) {
        return sdk_base_1.contracts.tokenBridgeChains(network);
    }
    // get the list of destination tokens that may be received on the destination chain
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        try {
            return [await tokenTransfer_js_1.TokenTransfer.lookupDestinationToken(fromChain, toChain, sourceToken)];
        }
        catch (e) {
            return [];
        }
    }
    getDefaultOptions() {
        return { payload: undefined };
    }
    async validate(request, params) {
        // Check that source and destination chains are different
        if (request.fromChain.chain === request.toChain.chain) {
            return {
                valid: false,
                params,
                error: new Error("Source and destination chains cannot be the same"),
            };
        }
        // Prevent transfers to/from SVM chains if the destination token is Token2022
        // except when using ExecutorTokenBridge
        // Attempting to manually redeem Token2022 tokens will fail if recipient account
        // has the immutableOwner extension, so just disable such transfers here
        // Executor route creates temporary account without the extension
        if ((0, sdk_base_2.chainToPlatform)(request.fromChain.chain) === "Solana") {
            const isToken2022 = await request.fromChain.isToken2022(request.source.id.address);
            if (isToken2022) {
                return {
                    valid: false,
                    params,
                    error: new Error("Transfers of Token-2022 assets from SVM chains are not supported via the Manual Token Bridge route. Please use the Executor Token Bridge route instead."),
                };
            }
        }
        if ((0, sdk_base_2.chainToPlatform)(request.toChain.chain) === "Solana") {
            const isToken2022 = await request.toChain.isToken2022(request.destination.id.address);
            if (isToken2022) {
                return {
                    valid: false,
                    params,
                    error: new Error("Transfers of Token-2022 assets to SVM chains are not supported via the Manual Token Bridge route. Please use the Executor Token Bridge route instead."),
                };
            }
        }
        const amt = sdk_base_1.amount.parse(params.amount, request.source.decimals);
        const validatedParams = {
            amount: params.amount,
            normalizedParams: { amount: amt },
            options: {},
        };
        return { valid: true, params: validatedParams };
    }
    async quote(request, params) {
        try {
            return request.displayQuote(await tokenTransfer_js_1.TokenTransfer.quoteTransfer(this.wh, request.fromChain, request.toChain, {
                token: request.source.id,
                amount: sdk_base_1.amount.units(params.normalizedParams.amount),
                protocol: "TokenBridge",
                ...params.options,
            }), params);
        }
        catch (e) {
            return {
                success: false,
                error: e,
            };
        }
    }
    async initiate(request, signer, quote, to) {
        const { params } = quote;
        const transfer = await tokenTransfer_js_1.TokenTransfer.destinationOverrides(request.fromChain, request.toChain, this.toTransferDetails(request, params, wormhole_js_1.Wormhole.chainAddress(signer.chain(), signer.address()), to));
        const txids = await tokenTransfer_js_1.TokenTransfer.transfer(request.fromChain, transfer, signer);
        return {
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: types_js_1.TransferState.SourceInitiated,
            originTxs: txids,
        };
    }
    async complete(signer, receipt) {
        if (!(0, types_js_1.isAttested)(receipt))
            throw new Error("The source must be finalized in order to complete the transfer");
        const toChain = this.wh.getChain(receipt.to);
        const dstTxIds = await tokenTransfer_js_1.TokenTransfer.redeem(toChain, receipt.attestation.attestation, signer);
        return {
            ...receipt,
            state: types_js_1.TransferState.DestinationInitiated,
            destinationTxs: dstTxIds,
        };
    }
    async resume(txid) {
        const xfer = await tokenTransfer_js_1.TokenTransfer.from(this.wh, txid, 10 * 1000);
        if (xfer.transfer.protocol !== "TokenBridge") {
            throw new Error("Transfer is not a TokenBridge transfer");
        }
        return tokenTransfer_js_1.TokenTransfer.getReceipt(xfer);
    }
    async *track(receipt, timeout) {
        yield* tokenTransfer_js_1.TokenTransfer.track(this.wh, receipt, timeout);
    }
    toTransferDetails(request, params, from, to) {
        return {
            from,
            to,
            protocol: "TokenBridge",
            token: request.source.id,
            amount: sdk_base_1.amount.units(params.normalizedParams.amount),
            ...params.options,
        };
    }
}
exports.TokenBridgeRoute = TokenBridgeRoute;
//# sourceMappingURL=manual.js.map